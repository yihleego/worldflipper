<!DOCTYPE html>
<html lang='en'>
<head>
    <title>Chat</title>
    <meta charset='UTF-8'>
    <meta content='chat' name='description'>
    <meta content='width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no' name='viewport'>
    <link href="styles/index.css" rel="stylesheet">
</head>
<body>
<main id='app'>
    <div class="main">
        <div class="char-room">
            <div class="panel">
                <div class="header">
                    <div class="avatar">
                        <img class="img" src="images/avatar.png">
                    </div>
                    <div class="info">
                        <h3 class="nickname">
                            <span class="display">{{user.nickname}}</span>
                            <span class="opt">
                                <img v-if="connected" @click="close" class="icon" src="images/online.svg">
                                <img v-else class="icon" src="images/offline.svg">
                                <img @click="" class="icon" src="images/exit.svg">
                            </span>
                        </h3>
                    </div>
                </div>
                <div class="tab">
                </div>
                <div class="contact-list">
                    <div v-for="contact in contacts" :class="contact.id === recipient.userId ? 'active' : ''" @click="switchUser(contact)" class="contact-item">
                        <div class="avatar">
                            <img class="img" src="images/avatar.png">
                        </div>
                        <div class="info">
                            <h3 class="nickname">
                                <span>{{contact.nickname}}</span>
                            </h3>
                        </div>
                    </div>
                </div>
            </div>
            <div class="chat">
                <div class="title">
                    <span class="">{{recipient.nickname}}</span>
                </div>
                <div class="message-list" id="message-list">
                    <div v-for="record in displayRecords">
                        <div v-if="record.isTime" class="timer">
                            <div class="content">{{record.time}}</div>
                        </div>
                        <div v-else :class="record.sender === user.userId ? 'right' : 'left'" class="message">
                            <div class="avatar">
                                <img class="img" src="images/avatar.png">
                            </div>
                            <!--{{record.status}} {{record.tries}}-->
                            <div class="bubble" :class="record.sender === user.userId ? 'primary' : ''">
                                <pre>{{record.content}}</pre>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="input-area">
                    <div class="toolbar">
                        <span class="icon"><img src="images/emoji.svg"></span>
                        <span class="icon"><img src="images/file.svg"></span>
                    </div>
                    <div class="content">
                        <textarea id="edit-box" v-model="message.content" @keydown="handleKeyCode($event)" class="edit-box" maxlength="2048"></textarea>
                    </div>
                    <div class="action">
                        <span class="desc">Press Ctrl+Enter to start a new line</span>
                        <button class="btn btn-send" @click="saveMessage" :disabled="!connected">Send</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</main>
<script src='scripts/vue.min.js'></script>
<script src='scripts/axios.min.js'></script>
<script src="scripts/protobuf.min.js"></script>
<script src="scripts/main.js"></script>
<script>
    const api = {
        contact: {
            get(callback) {
                $get({
                    url: `/api/chat/contacts`,
                    params: {'added': true}
                }, callback);
            },
        },
        message: {
            save(params, callback) {
                $post({
                    url: `/api/chat/messages`,
                    data: params,
                    headers: {'Message-Type': params.type}
                }, callback);
            },
            get(id, callback) {
                $get({
                    url: `/api/chat/messages/${id}`,
                }, callback);
            },
            mark(id, callback) {
                $patch({
                    url: `/api/chat/messages/${id}`,
                }, callback);
            },
            listUnread(params, callback) {
                $get({
                    url: `/api/chat/messages/unread`,
                    params: params
                }, callback);
            },
        },
    };
    const vm = new Vue({
        el: '#app',
        data: {
            url: "ws://localhost:10005/chat?access_token=",
            ws: null,
            connected: false,
            proto: {
                box: null,
                message: null,
                token: null,
            },
            messageStatus: {
                OK: 1,
                SENDING: 2,
                UNSAVED: 3,
                FAILED: 4,
            },
            user: {
                userId: 1,
                nickname: 'Name',
                token: null,
                signed: true,
            },
            contacts: [],
            message: {
                content: null,
                type: 'TEXT'
            },
            recipient: {
                userId: null,
                nickname: null,
            },
            totalRecords: {},
            displayRecords: [],
            sending: false,
            tasks: {},
            timers: {},
            codes: {
                ERROR: -1,
                UNKNOWN: 0,
                HEARTBEAT: 1,
                AUTHENTICATION: 2,
                ACCESS_GRANTED: 3,
                ACCESS_DENIED: 4,
                SEND_MESSAGE: 10,
                RECEIVE_MESSAGE: 11,
                PROCESSED_MESSAGE: 12,
                DELIVERED_MESSAGE: 13,
                DELIVERED_OFFLINE_MESSAGE: 14,
                SEND_REVOCATION: 15,
                RECEIVE_REVOCATION: 16,
                PROCESSED_REVOCATION: 17,
                DELIVERED_REVOCATION: 18,
                DELIVERED_OFFLINE_REVOCATION: 19,
                SEND_GROUP_MESSAGE: 10,
                RECEIVE_GROUP_MESSAGE: 11,
                PROCESSED_GROUP_MESSAGE: 12,
                DELIVERED_GROUP_MESSAGE: 13,
                DELIVERED_OFFLINE_GROUP_MESSAGE: 14,
                SEND_GROUP_REVOCATION: 15,
                RECEIVE_GROUP_REVOCATION: 16,
                PROCESSED_GROUP_REVOCATION: 17,
                DELIVERED_GROUP_REVOCATION: 18,
                DELIVERED_OFFLINE_GROUP_REVOCATION: 19,
            },
            messageTypes: {
                TEXT: "TEXT",
                IMAGE: "IMAGE",
                VIDEO: "VIDEO",
                FILE: "FILE",
            },
        },
        methods: {
            init() {
                protobuf.load("./google/protobuf/any.proto", (err, root) => {
                    if (err) {
                        throw err;
                    }
                    const proto =
                        `syntax = "proto3";
                        import "google/protobuf/any.proto";
                        package Chatter;
                        message Box { google.protobuf.Any data = 1; string message = 2; int32 code = 3; }
                        message Message { string id = 1; int64 recipient = 2; int64 sender = 3; }
                        message Token { string value = 1; }`;
                    let chat = protobuf.parse(proto, root);
                    this.proto.any = root.lookupType("google.protobuf.Any");
                    this.proto.box = chat.root.lookupType("Chatter.Box");
                    this.proto.message = chat.root.lookupType("Chatter.Message");
                    this.proto.token = chat.root.lookupType("Chatter.Token");
                    //this.connect();
                });
            },
            connect() {
                api.contact.get((result) => {
                    if (!result.success) {
                        //$notify.error(result.message);
                        return;
                    }
                    for (let i in result.data) {
                        result.data[i].nickname = 'nickname' + i
                    }
                    this.contacts = result.data;
                    if (this.contacts.length > 0) {
                        this.switchUser(this.contacts[0]);
                    }
                });
                let token = getAccessToken();
                if (!token) {
                    console.error("no tokens");
                    return;
                }
                this.user.token = token;
                this.ws = new WebSocket(this.url + this.user.token);
                this.ws.binaryType = "arraybuffer";
                this.ws.onopen = event => this.onopen(event);
                this.ws.onclose = event => this.onclose(event);
                this.ws.onmessage = event => this.onmessage(event);
                this.tasks.ping = setInterval(() => {
                    this.ping();
                }, 30000);
            },
            close() {
                for (let key in this.tasks) {
                    console.log("Removed task", key);
                    clearInterval(this.tasks[key]);
                    delete this.tasks[key];
                }
                if (this.ws.readyState === 1) {
                    this.ws.close();
                }
            },
            switchUser(user) {
                this.recipient = user;
                this.displayRecords = this.getUserRecords(user.userId);
                this.scrollToBottom();
            },
            handleKeyCode(event) {
                if (event.key === 'Enter') {
                    if (!event.ctrlKey) {
                        event.preventDefault();
                        this.saveMessage();
                    } else {
                        this.message.content += '\n';
                    }
                }
            },
            saveMessage() {
                document.getElementById('edit-box').focus();
                if (!this.connected
                    || this.sending
                    || this.message.content === null
                    || this.message.content === '') {
                    return;
                }
                let recipient = this.recipient.userId;
                let content = this.message.content;
                this.sending = true;
                this.message.content = null;
                let displayMessage = {
                    sender: this.user.userId,
                    recipient: recipient,
                    content: content,
                    status: this.messageStatus.SENDING,
                    time: this.format(new Date()),
                    tries: 0,
                };
                this.appendMessage(recipient, displayMessage);
                let saveMessage = {
                    recipient: recipient,
                    content: content,
                };
                api.message.save(saveMessage, (result) => {
                    this.sending = false;
                    if (!result.success) {
                        //$notify.error(result.message);
                        displayMessage.status = this.messageStatus.UNSAVED;
                        return;
                    }
                    let message = result.data;
                    let key = 'msg_check_' + message.id;
                    this.tasks[key] = setInterval(() => {
                        displayMessage.tries++;
                        if (displayMessage.tries === 3) {
                            clearInterval(this.tasks[key]);
                            delete this.tasks[key];
                            if (displayMessage.status === this.messageStatus.SENDING) {
                                displayMessage.status = this.messageStatus.FAILED;
                            }
                        }
                    }, 3000);
                    displayMessage.id = message.id;
                    this.sendMessage({id: message.id, recipient: message.recipient, sender: message.sender});
                });
            },
            readMessage(id, callback) {
                api.message.get(id, (result) => {
                    if (!result.success) {
                        //$notify.error(result.message);
                        return;
                    }
                    callback(result.data);
                    api.message.mark(id, (ignored) => {
                    });
                });
            },
            listUnread(params) {
                api.message.listUnread(params, (result) => {
                    if (!result.success) {
                        //$notify.error(result.message);
                        return;
                    }
                    if (result.data.length === 0) {
                        return;
                    }
                    let messages = result.data;
                    for (let i in messages) {
                        this.appendMessage(messages[i].sender, messages[i]);
                    }
                    this.listUnread({anchor: messages[messages.length - 1].id});
                });
            },
            appendMessage(userId, message) {
                message.timestamp = new Date().getTime();
                let records = this.getUserRecords(userId);
                if (records.length > 0 && !records.isTime) {
                    let lastTimestamp = records[records.length - 1].timestamp;
                    if (message.timestamp - lastTimestamp > 5 * 60 * 1000) {
                        records.push({time: message.time, isTime: true});
                    }
                }
                records.push(message);
                this.scrollToBottom();
            },
            deliveredMessage(message) {
                let key = 'msg_check_' + message.id;
                clearInterval(this.tasks[key]);
                delete this.tasks[key];
                let records = this.getUserRecords(message.recipient);
                for (let i = records.length - 1; i < records.length; i--) {
                    if (records[i].id === message.id) {
                        if (records[i].status === this.messageStatus.SENDING) {
                            records[i].status = this.messageStatus.OK;
                        }
                        break
                    }
                }
            },
            getUserRecords(userId) {
                let records = this.totalRecords[userId];
                if (!records) {
                    records = []
                    this.totalRecords[userId] = records;
                }
                return records;
            },
            scrollToBottom() {
                let box = this.$el.querySelector("#message-list");
                if (box.scrollTop <= 1 || Math.abs(box.scrollTop + box.offsetHeight - box.scrollHeight) <= 10) {
                    this.$nextTick(() => {
                        //console.log(box.scrollTop, box.scrollHeight, box.offsetHeight, box.scrollTop + box.offsetHeight - box.scrollHeight);
                        box.scrollTop = box.scrollHeight;
                    })
                }
            },
            ping() {
                this.send(this.codes.HEARTBEAT);
            },
            sendMessage(msg) {
                this.send(this.codes.SEND_MESSAGE, msg, this.proto.message);
            },
            receivedMessage(msg) {
                this.send(this.codes.RECEIVED_MESSAGE, msg, this.proto.message);
            },
            send(code, value, type) {
                let data = value && type ? this.pack(value, type) : null;
                let buffer = this.proto.box.encode({code: code, data: data}).finish();
                this.ws.send(buffer);
            },
            pack(value, type) {
                let encodedValue = type.encode(value).finish();
                return this.proto.any.create({value: encodedValue});
            },
            unpack(value, type) {
                return type.decode(value);
            },
            onopen(event) {
                console.log("Connected", event);
                this.connected = true;
                this.listUnread(null);
            },
            onclose(event) {
                console.log("Closed", event);
                this.connected = false;
                this.close();
            },
            onmessage(event) {
                let buffer = new Uint8Array(event.data);
                let box = this.unpack(buffer, this.proto.box);
                if (box.code === this.codes.RECEIVE_MESSAGE) {
                    let message = this.unpack(box.data.value, this.proto.message);
                    console.log('RECEIVE_MESSAGE', message);
                    this.readMessage(message.id, (msg) => {
                        this.appendMessage(msg.sender, msg);
                        this.receivedMessage(message);
                    });
                } else if (box.code === this.codes.DELIVERED_MESSAGE) {
                    let message = this.unpack(box.data.value, this.proto.message);
                    console.log('DELIVERED_MESSAGE', message);
                    this.deliveredMessage(message);
                } else if (box.code === this.codes.DELIVERED_OFFLINE_MESSAGE) {
                    let message = this.unpack(box.data.value, this.proto.message);
                    console.log('DELIVERED_OFFLINE_MESSAGE', message);
                    this.deliveredMessage(message);
                } else if (box.code === this.codes.HEARTBEAT) {
                    console.log('HEARTBEAT');
                } else if (box.code === this.codes.KICKED_OUT) {
                    console.log('KICKED_OUT');
                } else {
                    console.log(box);
                }
            },
            format(date) {
                let pattern = "yyyy-MM-dd HH:mm:ss";
                let o = {
                    "M+": date.getMonth() + 1,
                    "d+": date.getDate(),
                    "H+": date.getHours(),
                    "m+": date.getMinutes(),
                    "s+": date.getSeconds(),
                    "q+": Math.floor((date.getMonth() + 3) / 3),
                    "S": date.getMilliseconds()
                };
                if (/(y+)/.test(pattern)) {
                    pattern = pattern.replace(RegExp.$1, (date.getFullYear() + "").substr(4 - RegExp.$1.length));
                }
                for (let k in o) {
                    if (new RegExp("(" + k + ")").test(pattern)) {
                        pattern = pattern.replace(RegExp.$1, (RegExp.$1.length === 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length)));
                    }
                }
                return pattern;
            },
        },
        created() {
            this.init();
        },
    });

    function $get(value, callback) {
        $request('get', value, callback);
    }

    function $post(value, callback) {
        $request('post', value, callback);
    }

    function $put(value, callback) {
        $request('put', value, callback);
    }

    function $patch(value, callback) {
        $request('patch', value, callback);
    }

    function $delete(value, callback) {
        $request('delete', value, callback);
    }

    function $request(method, value, callback) {
        value.method = method;
        if (!value.headers) {
            value.headers = {}
        }
        value.headers['Access-Token'] = getAccessToken()
        axios(value).then((result) => {
            if (callback) {
                callback(result.data);
            }
        }).catch((error) => {
            if (callback) {
                callback({
                    success: false,
                    message: error.response ? error.response.statusText : null
                });
            }
        });
    }

    function getAccessToken() {
        return getCookie('access_token');
    }

    function getCookie(key) {
        let cookies = document.cookie.split("; ");
        for (let i = 0; i < cookies.length; i++) {
            let entry = cookies[i].split("=");
            if (entry[0] === key) {
                return decodeURI(entry[1]);
            }
        }
        return null;
    }
</script>
</body>
</html>